<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Quick start</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('a00013.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Quick start </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Solving a problem is done through several steps:</p>
<ul>
<li>Define your cost function by deriving one kind of function, depending on whether or not you want to provide a jacobian and/or a hessian.</li>
<li>Define your constraints functions in the same manner.</li>
<li>Build an instance of problem matching your requirements.</li>
<li>Use one of the solvers to solve your problem.</li>
</ul>
<p>The following example defines a cost function F and two constraints G0 and G1.</p>
<h2><a class="anchor" id="problem"></a>
Problem definition</h2>
<p>The problem that will be solved in this tutorial is the 71th problem of Hock-Schittkowski:</p>
<p><img class="formulaInl" alt="$min_{x \in \mathbb{R}^4} x_1 x_4 (x_1 + x_2 + x_3) + x_3$" src="form_41.png"/></p>
<p>with the following constraints:</p>
<ul>
<li><img class="formulaInl" alt="$x_1 x_2 x_3 x_4 \geq 25$" src="form_42.png"/></li>
<li><img class="formulaInl" alt="$x_1^2 + x_2^2 + x_3^2 + x_4^2 = 40$" src="form_43.png"/></li>
<li><img class="formulaInl" alt="$1 \leq x_1, x_2, x_3, x_4 \leq 5$" src="form_44.png"/></li>
</ul>
<h2><a class="anchor" id="cost"></a>
Defining the cost function.</h2>
<p>The library contains the following hierarchy of functions:</p>
<ul>
<li><a class="el" href="a00207.html#a1864afd8c0c95cea8029da9b52352736" title="Dense function.">roboptim::Function</a></li>
<li><a class="el" href="a00207.html#a3b8400e3e4a5bc0372d283a4db8eb0de" title="Legacy name of TwiceDifferentiableFunction.">roboptim::DerivableFunction</a></li>
<li><a class="el" href="a00207.html#a8fe946bb68641ff262c0cfef38af94d5" title="Legacy name of DifferentiableFunction.">roboptim::TwiceDerivableFunction</a></li>
<li><a class="el" href="a00207.html#ab03c6ad564de263af42983892cab684a">roboptim::QuadraticFunction</a></li>
<li><a class="el" href="a00207.html#abbf3e635a932ae99934936a092aec72c">roboptim::LinearFunction</a></li>
</ul>
<p>These types correspond to dense vectors and matrices relying on Eigen. RobOptim also support dense matrices and you can even extend the framework to support your own types.</p>
<p>When defining a new function, you have to derive your new function from one of those classes. Depending on the class you derive from, you will be have to implement one or several methods:</p>
<ul>
<li>impl_compute that returns the function's result has to be defined for all functions.</li>
<li>impl_gradient which returns the function's gradient is to be defined for DerivableFunction and its subclasses.</li>
<li>impl_hessian for TwiceDerivableFunction functions and its subclasses.</li>
</ul>
<p>It is usually recommended to derive from the deepest possible class of the hierarchy (deriving from TwiceDerivableFunction is better than DerivableFunction).</p>
<p>Keep in mind that the type of the function represents the amount of information the solver will get, not the real nature of a function (it is possible to avoid defining a hessian by deriving from DerivableFunction, even if you function can be derived twice).</p>
<p>In the following sample, a TwiceDifferentiableFunction will be defined.</p>
<div class="fragment"><pre class="fragment"><span class="keyword">struct </span>F : <span class="keyword">public</span> <a class="code" href="a00207.html#a664a3377f606592dfc57f9525c9afa37">TwiceDifferentiableFunction</a>
{
  F () : <a class="code" href="a00207.html#a664a3377f606592dfc57f9525c9afa37">TwiceDifferentiableFunction</a> (4, 1, <span class="stringliteral">&quot;x₀ * x₃ * (x₀ + x₁ + x₂) + x₃&quot;</span>)
  {
  }

  <span class="keywordtype">void</span>
  impl_compute (result_t&amp; result, <span class="keyword">const</span> argument_t&amp; x) <span class="keyword">const</span> <span class="keywordflow">throw</span> ()
  {
    result (0) = x[0] * x[3] * (x[0] + x[1] + x[2]) + x[3];
  }

  <span class="keywordtype">void</span>
  impl_gradient (gradient_t&amp; grad, <span class="keyword">const</span> argument_t&amp; x, size_type) <span class="keyword">const</span> throw ()
  {
    grad[0] = x[0] * x[3] + x[3] * (x[0] + x[1] + x[2]);
    grad[1] = x[0] * x[3];
    grad[2] = x[0] * x[3] + 1;
    grad[3] = x[0] * (x[0] + x[1] + x[2]);
  }

  <span class="keywordtype">void</span>
  impl_hessian (hessian_t&amp; h, <span class="keyword">const</span> argument_t&amp; x, size_type) <span class="keyword">const</span> throw ()
  {
    h (0, 0) = 2 * x[3];
    h (0, 1) = x[3];
    h (0, 2) = x[3];
    h (0, 3) = 2 * x[0] + x[1] + x[2];

    h (1, 0) = x[3];
    h (1, 1) = 0.;
    h (1, 2) = 0.;
    h (1, 3) = x[0];

    h (2, 0) = x[3];
    h (2, 1) = 0.;
    h (2, 2) = 0.;
    h (2, 3) = x[1];

    h (3, 0) = 2 * x[0] + x[1] + x[2];
    h (3, 1) = x[0];
    h (3, 2) = x[0];
    h (3, 3) = 0.;
  }
};
</pre></div><h2><a class="anchor" id="constraints"></a>
Defining the constraints.</h2>
<p>A constraint is no different from a cost function and can be defined in the same way than a cost function.</p>
<p>The following sample defines two constraints which are twice derivable functions.</p>
<div class="fragment"><pre class="fragment"><span class="keyword">struct </span>G0 : <span class="keyword">public</span> <a class="code" href="a00207.html#a664a3377f606592dfc57f9525c9afa37">TwiceDifferentiableFunction</a>
{
  G0 () : <a class="code" href="a00207.html#a664a3377f606592dfc57f9525c9afa37">TwiceDifferentiableFunction</a> (4, 1, <span class="stringliteral">&quot;x₀ * x₁ * x₂ * x₃&quot;</span>)
  {
  }

  <span class="keywordtype">void</span>
  impl_compute (result_t&amp; result, <span class="keyword">const</span> argument_t&amp; x) <span class="keyword">const</span> <span class="keywordflow">throw</span> ()
  {
    result (0) = x[0] * x[1] * x[2] * x[3];
  }

  <span class="keywordtype">void</span>
  impl_gradient (gradient_t&amp; grad, <span class="keyword">const</span> argument_t&amp; x, size_type) <span class="keyword">const</span> throw ()
  {
    grad[0] = x[1] * x[2] * x[3];
    grad[1] = x[0] * x[2] * x[3];
    grad[2] = x[0] * x[1] * x[3];
    grad[3] = x[0] * x[1] * x[2];
  }

  <span class="keywordtype">void</span>
  impl_hessian (hessian_t&amp; h, <span class="keyword">const</span> argument_t&amp; x, size_type) <span class="keyword">const</span> throw ()
  {
    h (0, 0) = 0.;
    h (0, 1) = x[2] * x[3];
    h (0, 2) = x[1] * x[3];
    h (0, 3) = x[1] * x[2];

    h (1, 0) = x[2] * x[3];
    h (1, 1) = 0.;
    h (1, 2) = x[0] * x[3];
    h (1, 3) = x[0] * x[2];

    h (2, 0) = x[1] * x[3];
    h (2, 1) = x[0] * x[3];
    h (2, 2) = 0.;
    h (2, 3) = x[0] * x[1];

    h (3, 0) = x[1] * x[2];
    h (3, 1) = x[0] * x[2];
    h (3, 2) = x[0] * x[1];
    h (3, 3) = 0.;
  }
};

<span class="keyword">struct </span>G1 : <span class="keyword">public</span> <a class="code" href="a00207.html#a664a3377f606592dfc57f9525c9afa37">TwiceDifferentiableFunction</a>
{
  G1 () : <a class="code" href="a00207.html#a664a3377f606592dfc57f9525c9afa37">TwiceDifferentiableFunction</a> (4, 1, <span class="stringliteral">&quot;x₀² + x₁² + x₂² + x₃²&quot;</span>)
  {
  }

  <span class="keywordtype">void</span>
  impl_compute (result_t&amp; result, <span class="keyword">const</span> argument_t&amp; x) <span class="keyword">const</span> <span class="keywordflow">throw</span> ()
  {
    result (0) = x[0]*x[0] + x[1]*x[1] + x[2]*x[2] + x[3]*x[3];
  }

  <span class="keywordtype">void</span>
  impl_gradient (gradient_t&amp; grad, <span class="keyword">const</span> argument_t&amp; x, size_type) <span class="keyword">const</span> throw ()
  {
    grad[0] = 2 * x[0];
    grad[1] = 2 * x[1];
    grad[2] = 2 * x[2];
    grad[3] = 2 * x[3];
  }

  <span class="keywordtype">void</span>
  impl_hessian (hessian_t&amp; h, <span class="keyword">const</span> argument_t&amp; x, size_type) <span class="keyword">const</span> throw ()
  {
    h (0, 0) = 2.;
    h (0, 1) = 0.;
    h (0, 2) = 0.;
    h (0, 3) = 0.;

    h (1, 0) = 0.;
    h (1, 1) = 2.;
    h (1, 2) = 0.;
    h (1, 3) = 0.;

    h (2, 0) = 0.;
    h (2, 1) = 0.;
    h (2, 2) = 2.;
    h (2, 3) = 0.;

    h (3, 0) = 0.;
    h (3, 1) = 0.;
    h (3, 2) = 0.;
    h (3, 3) = 2.;
  }
};
</pre></div><h2><a class="anchor" id="problem"></a>
Problem definition</h2>
<p>The last part of this tutorial covers how to build a problem and solve it. The steps are:</p>
<ul>
<li>Instanciate your functions (cost functions and constraints).</li>
<li>Pass them to the problem.</li>
<li>Optional: set a starting point.</li>
<li>Instanciate a solver which solves your class of problem.</li>
<li>Solve the problem by calling minimum.</li>
</ul>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> run_test ()
{
  <span class="comment">// Create cost function.</span>
  F f;

  <span class="comment">// Create problem.</span>
  <a class="code" href="a00077.html">solver_t::problem_t</a> pb (f);

  <span class="comment">// Set bounds for all optimization parameters.</span>
  <span class="comment">// 1. &lt; x_i &lt; 5. (x_i in [1.;5.])</span>
  <span class="keywordflow">for</span> (Function::size_type i = 0; i &lt; pb.function ().inputSize (); ++i)
    pb.argumentBounds ()[i] = Function::makeInterval (1., 5.);

  <span class="comment">// Set the starting point.</span>
  Function::vector_t start (pb.function ().inputSize ());
  start[0] = 1., start[1] = 5., start[2] = 5., start[3] = 1.;

  <span class="comment">// Create constraints.</span>
  boost::shared_ptr&lt;G0&gt; g0 (<span class="keyword">new</span> G0 ());
  boost::shared_ptr&lt;G1&gt; g1 (<span class="keyword">new</span> G1 ());

  F::intervals_t bounds;
  <a class="code" href="a00221.html#ga81acce0cec82db9dd19c849569fb034e" title="Scale vector.">solver_t::problem_t::scales_t</a> scales;

  <span class="comment">// Add constraints</span>
  bounds.push_back(Function::makeLowerInterval (25.));
  scales.push_back (1.);
  pb.addConstraint
    (boost::static_pointer_cast&lt;TwiceDifferentiableFunction&gt; (g0),
     bounds, scales);

  bounds.clear ();
  scales.clear ();

  bounds.push_back(Function::makeInterval (40., 40.));
  scales.push_back (1.);
  pb.addConstraint
    (boost::static_pointer_cast&lt;TwiceDifferentiableFunction&gt; (g1),
     bounds, scales);

  <span class="comment">// Initialize solver.</span>

  <span class="comment">// Here we are relying on a dummy solver.</span>
  <span class="comment">// You may change this string to load the solver you wish to use:</span>
  <span class="comment">//  - Ipopt: &quot;ipopt&quot;, &quot;ipopt-sparse&quot;, &quot;ipopt-td&quot;</span>
  <span class="comment">//  - Eigen: &quot;eigen-levenberg-marquardt&quot;</span>
  <span class="comment">//  etc.</span>
  <span class="comment">// The plugin is built for a given solver type, so chose it adequately.</span>
  SolverFactory&lt;solver_t&gt; factory (<span class="stringliteral">&quot;dummy-td&quot;</span>, pb);
  <a class="code" href="a00090.html">solver_t</a>&amp; solver = factory ();

  <span class="comment">// Compute the minimum and retrieve the result.</span>
  <a class="code" href="a00058.html#acd6988bec0b7bda9b8565232d32d1bae" title="Result type.">solver_t::result_t</a> res = solver.<a class="code" href="a00058.html#aef2460331a80efc404356e9b68269b8c" title="Returns the function minimum This solves the problem automatically, if it has not yet been solved...">minimum</a> ();

  <span class="comment">// Display solver information.</span>
  std::cout &lt;&lt; solver &lt;&lt; std::endl;

  <span class="comment">// Check if the minimization has succeeded.</span>

  <span class="comment">// Process the result</span>
  <span class="keywordflow">switch</span> (res.which ())
    {
    <span class="keywordflow">case</span> <a class="code" href="a00058.html#a12c31c6bd2e018b05a71d51dd5b34846a863bfbf9be9ec0e42ac65add3ea37dda" title="Solution has been found.">solver_t::SOLVER_VALUE</a>:
      {
        <span class="comment">// Get the result.</span>
        Result&amp; result = boost::get&lt;Result&gt; (res);

        <span class="comment">// Display the result.</span>
        std::cout &lt;&lt; <span class="stringliteral">&quot;A solution has been found: &quot;</span> &lt;&lt; std::endl
                  &lt;&lt; result &lt;&lt; std::endl;

        <span class="keywordflow">return</span> 0;
      }

    <span class="keywordflow">case</span> <a class="code" href="a00058.html#a12c31c6bd2e018b05a71d51dd5b34846a9d7660b10a44d0e05461a63e24182db5" title="Solution has been found but some problems happened.">solver_t::SOLVER_VALUE_WARNINGS</a>:
      {
        <span class="comment">// Get the result.</span>
        ResultWithWarnings&amp; result = boost::get&lt;ResultWithWarnings&gt; (res);

        <span class="comment">// Display the result.</span>
        std::cout &lt;&lt; <span class="stringliteral">&quot;A solution has been found: &quot;</span> &lt;&lt; std::endl
                  &lt;&lt; result &lt;&lt; std::endl;

        <span class="keywordflow">return</span> 0;
      }

    <span class="keywordflow">case</span> <a class="code" href="a00058.html#a12c31c6bd2e018b05a71d51dd5b34846ad1b2209e4a7e20a2c8baa1481106b374" title="Solution has yet to be found.">solver_t::SOLVER_NO_SOLUTION</a>:
    <span class="keywordflow">case</span> <a class="code" href="a00058.html#a12c31c6bd2e018b05a71d51dd5b34846a6b549430cbdf64b5dfeb36e006b3e15f" title="The solver failed to found a solution.">solver_t::SOLVER_ERROR</a>:
      {
        std::cout &lt;&lt; <span class="stringliteral">&quot;A solution should have been found. Failing...&quot;</span>
                  &lt;&lt; std::endl
                  &lt;&lt; boost::get&lt;SolverError&gt; (res).what ()
                  &lt;&lt; std::endl;

        <span class="keywordflow">return</span> 2;
      }
    }

  <span class="comment">// Should never happen.</span>
  assert (0);
  <span class="keywordflow">return</span> 42;
}
</pre></div><p>This is the last piece of code needed to instantiate and resolve an optimization problem with this package.</p>
<p>To see more usage examples, consider looking at the test directory of the project which contains the project's test suite. </p>
</div></div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="index.html">User manual</a>      </li>
</body>
</html>
